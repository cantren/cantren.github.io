
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>SimBox - Robosub Simulator</title>	
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				margin: 0px;
				overflow: hidden;
				}
			#info {
				position: absolute;
				top: 0px; width: 100%;
				text-align:center;
				padding: 5px;
				
			}
			#inset  {
				width: 200px;
				height: 200px;
				background-color: #fff; /* or transparent; will show through only if renderer alpha: true */
				border: 1px solid black; /* or none; */
				margin: 20px;
				padding: 0px;
				position: absolute;
				left: 0px;
				bottom: 0px;
    				z-index: 100;
			}
			#inset2  {
				width: 200px;
				height: 200px;
				background-color: transparent; /* or transparent; will show through only if renderer alpha: true */
				border: 1px solid black; /* or none; */
				margin: 20px;
				padding: 0px;
				position: fixed;
				right: 0px;
				bottom: 0px;
    				z-index: 100;
			}
			<!--.styling{
				background-color:black;
				color:lime;
				font: bold 16px MS Sans Serif;
				padding: 3px;
				position: fixed;
				left: 0px;
				top: 0px;
				}-->
			//What is this?
			a {
				color: #000000;
			}
			//What is this?
		</style>
	</head>
	<body>
		<div id="infoButton"></div>
		<div id="infoBox" title="Demo Information">
		Movement controls: <br/>
		<ul>
		<li>W/S: Translate Forward/Backward
		<li>A/D: Translate Left/Right
		<li>Mouse position: Up/Down for dive and surface, Left/Right to Rotate
		<li>Z: Reset position and rotation.
		</ul>
		This page's source code can be found at
		<a href="http://github.io/cantren/cantren.github.io/">http://github.io/cantren/cantren.github.io/</a>
		</div>
		<div id="info"><a href="https://github.com/cantren/cantren.github.io/" target="_blank">Code</a></a> - Please "fork" as this page changes often. - <a href="https://www.linkedin.com/pub/nicholas-cantrell/7b/808/987" target="_blank">LinkedIn</a></div>
		<div id="container">
		<div id="inset">
		<script src="../js/three.min.js"></script>
		<script src="js/jquery-1.9.1.js"></script>
		<script src="js/jquery-ui.js"></script>
		<link rel=stylesheet href="js/jquery-ui.css" />
		<link rel=stylesheet href="js/info.css"/>
		<script src="../js/FirstPersonControls.js"></script>
		<script src="../js/KeyboardState.js"></script>
		<script src="../js/Mirror.js"></script>
		<script src="../js/WaterShader.js"></script>
		<script src="../js/material.js"></script>


		<script src="../js/Detector.js"></script>
		<script src="../js/stats.min.js"></script>
		
		<script src="../js/josdirksen/dat.gui.js"></script> 
		<script src="js/MTLLoader.js"></script>
		<script type="text/javascript" src="js/OBJMTLLoader.js"></script>
		<script type="text/javascript" src="js/OBJLoader.js"></script>

		<script src="../js/CSS3DStereoRenderer.js"></script>
		
		
		<script src="../js/BrightnessContrastShader.js"></script>
		<script src="../js/ShaderPass.js"></script>
		<script src="../js/EffectComposer.js"></script>
		<script src="../js/RenderPass.js"></script>
		<script src="../js/CopyShader.js"></script>
		<script src="../js/StereoEffect.js"></script>
		<script src="../js/info.js"></script>


  		
					<span id="digitalclock" class="styling"></span>

<script>
<!--

//LCD Clock script- by javascriptkit.com
//Visit JavaScript Kit (http://javascriptkit.com) for script
//Credit must stay intact for use

var alternate=0
var standardbrowser=!document.all&&!document.getElementById

if (standardbrowser)
document.write('<form name="tick"><input type="text" name="tock" size="11"></form>')

function show(){
if (!standardbrowser)
var clockobj=document.getElementById? document.getElementById("digitalclock") : document.all.digitalclock
//var Digital=new Date("July 28, 2014 11:13:00")
var RealTime=new Date()
var year=15
var month=7
var day=24
var hours=RealTime.getHours()
//var hours=Digital.getHours()
//var hoursReal=RealTime.getHours()
var minutes=RealTime.getMinutes()
//var minutes=Digital.getMinutes()
//var minutesReal=RealTime.getMinutes()
var seconds=RealTime.getSeconds()
var dn="AM"

if (hours==12) dn="PM" 
if (hours>12){
dn="PM"
//hours=hours-12
}

if (hours==0) hours=12
if (hours.toString().length==1)
hours="0"+hours
if (minutes<=9)
minutes="0"+minutes
if (seconds<=9)
seconds="0"+seconds
if (standardbrowser){
if (alternate==0)
document.tick.tock.value=hours+" : "+minutes+" "+dn
else
document.tick.tock.value=hours+"   "+minutes+" "+dn
}
else{
if (alternate==0)
clockobj.innerHTML=month+" / "+day+" / "+year+"   "+hours+" : "+minutes+" : "+seconds+" "+"<sup style='font-size:70%'>"+dn+"</sup>"
else
clockobj.innerHTML=month+" / "+day+" / "+year+"   "+hours+" : "+minutes+" : "+seconds+" "+"<sup style='font-size:70%'>"+dn+"</sup>"
}
alternate=(alternate==0)? 1 : 0
setTimeout("show()",1000)
}
window.onload=show

//-->
/*
<p>This free script provided by<br/>
<a href="http://javascriptkit.com">JavaScript
Kit</a></p>
*/
</script>


<script>
/*
The MIT License

Copyright Â© 2010-2015 three.js authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

#Copyright Notes:
1)SimBox started as a JavaScript "learning experiment" with modifications made to code which should be attributed to the authors of the three.js examples under the MIT License "http://threejs.org/examples/webgl_shaders_ocean.html" and "http://threejs.org/examples/webgl_loader_obj_mtl.html"
2)Significant effort has been made to track, identify, and flag all "borrowed" code which was used to learn the dat.gui.js and three.js libraries
3)The most heavily "borrowed" code(that isn't from three.js examples) is actually from the work of a jsFiddle.net author(previously unattributed user, later identified as "WestLangley") who is assumed to be the same stackoverflow user who answered a question about a downward facing camera here: http://stackoverflow.com/a/16227714
4)To the knowledge of the author of this "index.html" file, all "borrowed" code has since been mutilated/revised/changed/modified/or adapted to nullify any remaining claims to the work with the exception of the code produced by WestLangley and those works which are protected under the MIT License described above.
*/
			//source: MIT License OR "This code no longer appears to contain anything that belongs to josdirksen?"
			if ( ! Detector.webgl ) {
				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";
			}
			//source: MIT License OR "This code no longer appears to contain anything that belongs to josdirksen?"

			var container, container2, stats;//cargo cult code? comment out this line please(may be desired in future)
			var camera, camera2, camera3, camControls, camControls2, camControls3, scene, scene2, renderer, renderer2;//these are actually usefull
			var composer;
			var testParams, testPass;			

			var CANVAS_WIDTH = 300,
			    CANVAS_HEIGHT = 300,
			    CAM_DISTANCE = 300;//This doesn't look like cargo cult code but should be sanity checked at some point
			var clock = new THREE.Clock();//I spent a long time debugging because I forgot to initialize this
			var keyboard = new KeyboardState();//this appears to help with keyboard input... Part of FPS controls/Key bindings?
			
//I'll admit: I can't remember what this does or where it came from
var parameters = {
				width: 2000,
				height: 2000,
				widthSegments: 250,
				heightSegments: 250,
				depth: 1500,
				param: 4,
				filterparam: 1
			}
//I'll admit: I can't remember what this does or where it came from			
			var waterNormals;
			var audio = new Audio('images/bell.mp3');
			mousething = false;
			resetfilename = "";
			obstaclesLoaded = false;
			obstacles2Loaded = false;
			transdecLoaded = false;
			transdec2Loaded = false;
	                savecsv1 = true;
	                savecsv2 = true;
	                savecsv3 = true;
	                savecsv4 = true;
	                savecsv5 = true;
	                savecsv6 = true;
	                imagenumber = 0;
			mouseposx = 0;
	                mouseposy = 0;
	                imageletter = 66;
	                filename1 = "";
	                filename2 = "";
			drivereverse = false;
	                autoForward = false;
	                autoBackward = false;
			autopilotrun = false;
			pathmarker1Points = false;
			pathmarker2Points = false;
			pathmarker3Points = false;
			pathmarker4Points = false;
			pathmarker5Points = false;
			pathmarker6Points = false;
			pathmarker7Points = false;
			octagon1Points = false;
			octagon2Points = false;
			buoy1Points = false;
			buoy2Points = false;
			buoy1Backup = false;
			buoy2Backup = false;
			buoy3Points = false;
			validationgatePoints = false;
			maneuverPoints = false;
	
			pathmarker1Reward = false;
			pathmarker2Reward = false;
			pathmarker3Reward = false;
			pathmarker4Reward = false;
			pathmarker5Reward = false;
			pathmarker6Reward = false;
			pathmarker7Reward = false;
			octagon1Reward = false;
			octagon2Reward = false;
			octagon1Center = false;
      			octagon2Center = false;
			octagon1Done = false;
				        
			buoy1Reward = false;
			buoy2Reward = false;
			buoy3Reward = false;
			validationgateReward = false;
			maneuverReward = false;
	
			data = [["filename1", "filename2", "position.x", "position.y", "position.z", "rotation.y","mousex","mousey","W","A","S","D","validationgatePoints","pathmarker1Points","buoy1Points","buoy1Backup","buoy2Points","buoy2Backup","buoy3Points","pathmarker2Points","maneuverPoints","pathmarker3Points","pathmarker4Points","pathmarker5Points","octagon1Points","pathmarker6Points","pathmarker7Points","octagon2Points"]];	
			init();
			animate();
			function testWebSocket() { 
				//websocket = new WebSocket("ws://192.168.1.34:8081/");
				websocket = new WebSocket("ws://127.0.0.01:8765/");
				websocket.onopen = function(evt) { onOpen(evt) };
				websocket.onclose = function(evt) { onClose(evt) };
				websocket.onmessage = function(evt) { onMessage(evt) };
				websocket.onerror = function(evt) { onError(evt) }; 
			} 
			function onOpen(evt) {console.log("You are connected.")}//doSend("Frame" + ", Xpos" + ", Ypos" + ", Zpos" + ", Yaw" + ", Mouse.x" + ", Mouse.y" + ", xacceleration" + ", yacceleration" + ", zacceleration" + ", yangvelocity" + ", Screenshot1" + ", Screenshot2");}
			function onClose(evt) {console.log("You are no longer connected.")}
			function onMessage(evt) {
				render();
				console.log("RESPONSE:" + evt.data ); 
				//websocket.close(); 
			}
			function onError(evt) {console.log(evt);}
			function doSend(message) {websocket.send(message); console.log("mousex: " + "0" +" mousey: " + "0")}// console.log(message);}
			
	                //credit dotJayEss (source: http://www.html5gamedevs.com/topic/13638-renderer-canvas-to-image/#comment-141518)
			//Returns a region of the canvas as a base64 dataURL
	                function extractRegion(renderer, x, y, width, height){
    				var sourceCanvas = renderer.extract.canvas();
    				var sourceContext = renderer.getContext('2d');
    				var extractCanvas = document.createElement('canvas');
    				var extractContext = extractCanvas.getContext('2d');
    				var imageData = sourceContext.getImageData(x, y, width, height);
    
				extractCanvas.width = width;
    				extractCanvas.height = height;
    				extractContext.putImageData(imageData, 0, 0);
    				return extractCanvas.toDataURL();
			}
	    /**
     * Converts data URI in 'image/png' format to an image data object
     * @param dataURL Base64 encoded string
     * @returns {ImageData/undefined}
     */
	/*
    convertDataURLToImage
    Data = function (dataURL) {
        if (dataURL !== undefined && dataURL !== null) {
            var canvas, context, image, imageData;
            canvas = document.createElement('canvas');
            canvas.width = 470;
            canvas.height = 470;
            context = canvas.getContext('2d');
            image = new Image();

            image.addEventListener('load', function(){
                context.drawImage(image, 0, 0, canvas.width, canvas.height);
                imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                //how do i return this?
            }, false);
            image.src = dataURL;

            return imageData;
        }
    }*/
/*			function resizedataURL(datas, wantedWidth, wantedHeight){
    				var extractCanvas = document.createElement('canvas');
    				var extractContext = extractCanvas.getContext('2d');
    				//var img = new Image();
				//img.src = datas;
				extractCanvas.width = wantedWidth;
    				extractCanvas.height = wantedHeight;
    				extractContext.putImageData(convertDataURLtoImageData(datas), 0, 0);
    				return extractCanvas.toDataURL();
			}
	                //credit dotJayEss (source: http://www.html5gamedevs.com/topic/13638-renderer-canvas-to-image/#comment-141518)
*/
	function toDataURL(src, callback, outputFormat) {
  var img = new Image();
  img.crossOrigin = 'Anonymous';
  img.onload = function() {
    var canvas = document.createElement('CANVAS');
    var ctx = canvas.getContext('2d');
    var dataURL;
    canvas.height = this.naturalHeight;
    canvas.width = this.naturalWidth;
    ctx.drawImage(this, 0, 0);
    dataURL = canvas.toDataURL(outputFormat);
    callback(dataURL);
  };
  img.src = src;
  if (img.complete || img.complete === undefined) {
    img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
    img.src = src;
  }
}
	function resizedataURL(datas, wantedWidth, wantedHeight)
    {
        // We create an image to receive the Data URI
        var img = document.createElement('img');

        // When the event "onload" is triggered we can resize the image.
        img.onload = function()
            {        
                // We create a canvas and get its context.
                var canvas = document.createElement('canvas');
                var ctx = canvas.getContext('2d');

                // We set the dimensions at the wanted size.
                canvas.width = wantedWidth;
                canvas.height = wantedHeight;

                // We resize the image with the canvas method drawImage();
                ctx.drawImage(this, 0, 0, wantedWidth, wantedHeight);

                var dataURI = canvas.toDataURL();

                /////////////////////////////////////////
                // Use and treat your Data URI here !! //
                /////////////////////////////////////////
            };

        // We put the Data URI in the image's src attribute
        img.src = datas;
	//console.log(typeof img);
	var c = document.getElementById("myCanvas");
        var ctx2 = c.getContext("2d");
        var img2 = document.getElementById("img");
        ctx2.drawImage(img2, 10, 10);
        return c.toDataURL();
	//return String(img).replace("<img src =\"", "").replace(">","");
    }
	
	/*
	                function resizedataURL(srcUrl, dstW, dstH){
				var cpuScaleAspect = function(maxW, maxH, curW, curH){
					var ratio = curH / curW;
					if( curW >= maxW && ratio <= 1 ){ 
						curW	= maxW;
						curH	= maxW * ratio;
					}else if(curH >= maxH){
						curH	= maxH;
						curW	= maxH / ratio;
					}
					return { width: curW, height: curH };
				}
				var onLoad = function(){
					var canvas	= document.createElement('canvas');
					canvas.width	= dstW;	canvas.height	= dstH;
					var ctx		= canvas.getContext('2d');
					ctx.fillStyle	= "black";
					ctx.fillRect(0, 0, canvas.width, canvas.height);
					var scaled	= cpuScaleAspect(canvas.width, canvas.height, image.width, image.height);
					var offsetX	= (canvas.width  - scaled.width )/2;
					var offsetY	= (canvas.height - scaled.height)/2;
					ctx.drawImage(image, offsetX, offsetY, scaled.width, scaled.height);
					var mimetype	= "image/png";
					var newDataUrl	= canvas.toDataURL(mimetype);
					//callback && callback(newDataUrl)
				}.bind(this);
				var image 	= new Image();
				image.onload	= onLoad;
				image.src	= srcUrl;
			}*/	
			/*function resizedataURL(datas, wantedWidth, wantedHeight)
    			{
	        		// We create an image to receive the Data URI
        			var img = document.createElement('img');
				
       				// When the event "onload" is triggered we can resize the image.
        			img.onload = function()
            			{        
	                		// We create a canvas and get its context.
                			var canvas = document.createElement('canvas');
                			var ctx = canvas.getContext('2d');

                			// We set the dimensions at the wanted size.
                			canvas.width = wantedWidth;
                			canvas.height = wantedHeight;

                			// We resize the image with the canvas method drawImage();
                			ctx.drawImage(this, 0, 0, wantedWidth, wantedHeight);

                			var dataURI = canvas.toDataURL();
					//console.log(dataURI);

                		};
        			img.src = datas;
				//console.log(img);
				return img.toDataURL();
    			}*/
			function imageToDataUri(img, width, height) {

    				// create an off-screen canvas
    				var canvas = document.createElement('canvas'),
        			ctx = canvas.getContext('2d');

    				// set its dimension to target size
    				canvas.width = width;
    				canvas.height = height;

	  			// draw source image into the off-screen canvas:
    				ctx.drawImage(img, 0, 0, width, height);

	  			// encode image to data-uri with base64 version of compressed image
    				return canvas.toDataURL();
			}
/*
			function resizedataURL(datas,targetWidth,targetHeight) {
				var img = new Image;

				img.src = datas;
    				var newDataUri = imageToDataUri(this, targetWidth, targetHeight);
				
    				return newDataUri
			}*/
			//source: This entire "init()" function is very "boilerplate" from the examples at http://threejs.org/examples/ covered under the MIT License
			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				testWebSocket();
				
				globalyawKp = 500; globalyawKi = 0.00001; globalyawKd = 0.000000001;

				
				previouserrorYaw = 0;
				previousDeltaZ = 0;
				integralYaw = 0;
				previouserrorDepth = 0;
				integralDepth = 0;
				victoryCounter = 0;
				turnCounter = 0;
				lazybot = 0;
				record = false;
				
				targetx =  0;
				targety = -1.5;
				targetz = 0;
				
				frameCounter = 0;
				desiredFrameCounter1 = 0;
				desiredFrameCounter2 = 0;
				mouseposx = 0;		
				mouseposy = 0;		
				record = false;
				//runonce = true;
				renderer = new THREE.WebGLRenderer( { antialias: true, preserveDrawingBuffer: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				//renderer.setSize( 80, 80 );
				
				
				//uncomment these lines for VR
				//effect = new THREE.StereoEffect( renderer );
				//effect.eyeSeparation = 10;
				//effect.setSize( window.innerWidth, window.innerHeight );
				//uncomment these lines for VR
				container.appendChild( renderer.domElement );
				

				
				
				//renderer = new THREE.CSS3DStereoRenderer();
				//renderer.setSize( window.innerWidth, window.innerHeight );
				//renderer.domElement.style.position = 'absolute';
				//document.getElementById( 'container' ).appendChild( renderer.domElement );
				
				container2 = document.getElementById('inset');
				// renderer
				renderer2 = new THREE.WebGLRenderer( { antialias: false, preserveDrawingBuffer: true } );
				renderer2.setClearColor( 0xf0f0f0, 1 );
				renderer2.setSize( 200, 200 );
				container2.appendChild( renderer2.domElement );


	

				scene = new THREE.Scene();
				//scene.overrideMaterial = new THREE.MeshDepthMaterial();
				scene2 = new THREE.Scene();
				//scene2.overrideMaterial = new THREE.MeshDepthMaterial();
				
				//add water colored fog
				var fogintensityrandom = ((Math.random() * 0.0275))
				scene.fog = new THREE.FogExp2( 0x008080, 0.1275 + fogintensityrandom );
				scene2.fog = new THREE.FogExp2( 0x008080, 0.1275 + fogintensityrandom );
				
				camera = new THREE.PerspectiveCamera(41, window.innerWidth / window.innerHeight, 0.5, 3000000);
//buoy closeup location
				/*
				camera.position.x = -16.73;//pool line of symetry is x axis
				camera.position.y = -2.52;//water depth
			        camera.position.z = -22.57;//how close to the wall are you
				*/

//normal starting location
				camera.position.x = 0.0;//pool line of symetry is x axis
				camera.position.y = -2.0;//water depth
			        camera.position.z = -28.0;//how close to the wall are you
				
				camera.position.y += (Math.random()*0.5 - 0.5);
				camera.position.x += (Math.random()*4 - 2);
				camera.position.z += (Math.random()*4 - 2);
//normal starting location
			        camera.rotation.z = 3.06;
				camera.near = 0.5;
				camera.far = 21.5;
			        
			        camera2 = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.5, 3000000);
			        camera2.up = camera.up; // important!

//buoy closeup location
				/*
			        camera2.position.x = -16.73;//pool line of symetry is x axis
				camera2.position.y = -2.52;//water depth
			        camera2.position.z = -22.57;//how close to the wall are you
				*/
//buoy closeup location

//normal starting location
			        camera2.position.x = 0.0;//pool line of symetry is x axis
				camera2.position.y = -2.0;//water depth
			        camera2.position.z = -28.0;//how close to the wall are you
			        camera2.rotation.z = 3.06;		
//normal starting location
				//camera.position.set( 0, -2, -28 );
				
				camera3 = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.5, 3000000);
			        camera3.up = camera.up; // important!
			        
				camera3.position.x = 0.0;//pool line of symetry is x axis
				camera3.position.y = -2.0;//water depth
			        camera3.position.z = -28.0;//how close to the wall are you
			        
			        //POST PROCESSING
				//Create Shader Passes
				renderPass = new THREE.RenderPass( scene, camera );
				copyPass = new THREE.ShaderPass( THREE.CopyShader );
				
				brightnessContrastPass = new THREE.ShaderPass( THREE.BrightnessContrastShader );
				brightnessContrastPass.uniforms[ "contrast" ].value = 0.8;
				
				camControls = new THREE.FirstPersonControls( camera, renderer.domElement );
				camControls.lookSpeed = 0.05; //Pitch Thrust to drag ratio
				camControls.movementSpeed = 0.25; // FWD BKWD Thrust to drag ratio 
				camControls.verticalMin = -50.0; //basement floor level
				camControls.verticalMax = 10.0; //sky ceiling level
				camControls.lon = 180;
				//controls.lat = someOtherDegrees;
				
				camControls2 = new THREE.FirstPersonControls( camera2, renderer2.domElement );
				camControls2.lookSpeed = 0.05; //Pitch Thrust to drag ratio
				camControls2.movementSpeed = 0.25; // FWD BKWD Thrust to drag ratio 
				camControls2.verticalMin = -50.0; //basement floor level
				camControls2.verticalMax = 10.0; //sky ceiling level
				camControls2.lon = 180;
				
				camControls3 = new THREE.FirstPersonControls( camera2, renderer2.domElement );
				camControls3.lookSpeed = 0.05; //Pitch Thrust to drag ratio
				camControls3.movementSpeed = 0.25; // FWD BKWD Thrust to drag ratio 
				camControls3.verticalMin = -50.0; //basement floor level
				camControls3.verticalMax = 10.0; //sky ceiling level
				
				//camera.rotation.y = 1.4;
			        
				//var newMoveSpeed = (Math.random() * 3.75);
				//camControls.movementSpeed = 0.25+newMoveSpeed;
				//camControls2.movementSpeed = 0.25+newMoveSpeed;
					
				
				//Add scene lighting
				lightRed = new THREE.HemisphereLight( 0xff0000, 0x008080, 1 );//I tried changing the light color here to see what would happen
				lightRed.position.set( - 1, 1, - 1 ); //my hemisphere flipped upside down
				lightRed.intensity = .25;
				scene.add( lightRed );//I changed the name to distinguish a negative y value from "sunlight"

				light2Red = new THREE.HemisphereLight( 0xff0000, 0x008080, 1 );//I tried changing the light color here to see what would happen
				light2Red.position.set( - 1, 1, - 1 ); //my hemisphere flipped upside down
				light2Red.intensity = .25;
				scene2.add( light2Red );//I changed the name to distinguish a negative y value from "sunlight"
				
				lightGreen = new THREE.HemisphereLight( 0x5eff00, 0x008080, 1 );//I tried changing the light color here to see what would happen
				lightGreen.position.set( - 1, 1, - 1 ); //my hemisphere flipped upside down
				lightGreen.intensity = .25;
				scene.add( lightGreen );//I changed the name to distinguish a negative y value from "sunlight"

				light2Green = new THREE.HemisphereLight( 0x5eff00, 0x008080, 1 );//I tried changing the light color here to see what would happen
				light2Green.position.set( - 1, 1, - 1 ); //my hemisphere flipped upside down
				light2Green.intensity = .25;
				scene2.add( light2Green );//I changed the name to distinguish a negative y value from "sunlight"
				
				lightBlue = new THREE.HemisphereLight( 0x00a9ff, 0x008080, 1 );//I tried changing the light color here to see what would happen
				lightBlue.position.set( - 1, 1, - 1 ); //my hemisphere flipped upside down
				lightBlue.intensity = .25;
				scene.add( lightBlue );//I changed the name to distinguish a negative y value from "sunlight"

				light2Blue = new THREE.HemisphereLight( 0x00a9ff, 0x008080, 1 );//I tried changing the light color here to see what would happen
				light2Blue.position.set( - 1, 1, - 1 ); //my hemisphere flipped upside down
				light2Blue.intensity = .25;
				scene2.add( light2Blue );//I changed the name to distinguish a negative y value from "sunlight"
				
				//More scene lighting
				//Red
				ambientLightRed = new THREE.AmbientLight(0xff0000);
				ambientLightRed.intensity = .375;
				scene.add(ambientLightRed);
				
				ambientLight2Red = new THREE.AmbientLight(0xff0000);
				ambientLight2Red.intensity = .375;
				scene2.add(ambientLight2Red);
				
				//Green
				ambientLightGreen = new THREE.AmbientLight(0x5eff00);
				ambientLightGreen.intensity = .375;
				scene.add(ambientLightGreen);
				
				ambientLight2Green = new THREE.AmbientLight(0x5eff00);
				ambientLight2Green.intensity = .375;
				scene2.add(ambientLight2Green);
				
				//Blue
				ambientLightBlue = new THREE.AmbientLight(0x00a9ff);
				ambientLightBlue.intensity = .375;
				scene.add(ambientLightBlue);
				
				ambientLight2Blue = new THREE.AmbientLight(0x00a9ff);
				ambientLight2Blue.intensity = .375;
				scene2.add(ambientLight2Blue);

				/*
				//HemisphereLight details
				lightRed lightRed.intensity = .25;
				light2Red light2Red.intensity = .25;
				lightGreen lightGreen.intensity = .25;
				light2Green light2Green.intensity = .25;
				lightBlue lightBlue.intensity = .25;
				light2Blue light2Blue.intensity = .25;
				//HemisphereLight details

				//ambient light details
				ambientLightRed ambientLightRed.intensity = .375;
				ambientLight2Red ambientLight2Red.intensity = .375;
				ambientLightGreen ambientLightGreen.intensity = .375;
				ambientLight2Green ambientLight2Green.intensity = .375;
				ambientLightBlue ambientLightBlue.intensity = .375;
				ambientLight2Blue ambientLight2Blue.intensity = .375;
				//ambient light details
				*/

				
				//light up the sun
				//spotLightSUN = new THREE.SpotLight(0xFFFFFF);
				//spotLightSUN.position.set(100, 140, -130);
				//spotLightSUN.intensity = 1000;
				//scene.add(spotLightSUN);
				
				//Add the three spotlights representing the sun(intensity will be modified as a function of depth)
				spotLightRED = new THREE.SpotLight(0xff0000);
				spotLightRED.position.set(100, 140, -130);
				spotLightRED.intensity = .85;
				scene.add(spotLightRED);
				
				spotLightRED2 = new THREE.SpotLight(0xff0000);
				spotLightRED2.position.set(100, 140, -130);
				spotLightRED2.intensity = .85;
				scene2.add(spotLightRED2);
				
				spotLightBLUE = new THREE.SpotLight(0x00a9ff);
				spotLightBLUE.position.set(100, 140, -130);
				spotLightBLUE.intensity = .85;
				scene.add(spotLightBLUE);
				
				spotLightBLUE2 = new THREE.SpotLight(0x00a9ff);
				spotLightBLUE2.position.set(100, 140, -130);
				spotLightBLUE2.intensity = .85;
				scene2.add(spotLightBLUE2);
				
				spotLightGREEN = new THREE.SpotLight(0x5eff00);
				spotLightGREEN.position.set(100, 140, -130);
				spotLightGREEN.intensity = .85;
				scene.add(spotLightGREEN);
				
				spotLightGREEN2 = new THREE.SpotLight(0x5eff00);
				spotLightGREEN2.position.set(100, 140, -130);
				spotLightGREEN2.intensity = .85;
				scene2.add(spotLightGREEN2);
				//Add the three spotlights representing the sun(intensity will be modified as a function of depth)
				
				
				// add spotlight for the shadows
				/*
				var spotLight = new THREE.SpotLight(0xffffff);
				spotLight.position.set(100, 140, 130);
				spotLight.intensity = 2;
				scene.add(spotLight);
				
				var spotLight2 = new THREE.SpotLight(0xffffff);
				spotLight2.position.set(100, 140, 130);
				spotLight2.intensity = 2;
				scene2.add(spotLight2);
				*/


				//load and insert the obj meshes and mtl textures
				//the "secret sauce" is in these .obj and .mtl files.
//				var loader = new THREE.OBJLoader(); //this object does the work
				var loader = new THREE.OBJMTLLoader(); //this object does the work
//
//				loader.load('../obj/transdec OBJ/transdec test.obj', function ( object ) {
				loader.load('../obj/transdec OBJ/transdec test.obj', '../obj/transdec OBJ/transdec test.mtl', function ( object ) {
					object.position.y = -12.975;//experimentally generated via trial and error
//					for(var i in object.children) {
//					        object.children[i].material = new THREE.MeshDepthMaterial({color: 0x2194CE});
//						}
					scene.add( object );//to make a Robosub you would likely need to change it's name from "object"
					transdecLoaded = true;
					});
//				loader.load('../obj/robosub obstacles/obstacles.obj', function ( object ) {
				loader.load('../obj/robosub obstacles/obstacles.obj', '../obj/robosub obstacles/obstacles.mtl', function ( object ) {
					object.position.y = -12.975;//experimentally generated via trial and error
//					for(var i in object.children) {
//					        object.children[i].material = new THREE.MeshDepthMaterial({color: 0x2194CE});
//						}
					scene.add( object );//to make a Robosub you would likely need to change it's name from "object"
					obstaclesLoaded = true;
					});
//				loader.load('../obj/transdec OBJ/transdec test.obj', function ( object ) {
				loader.load('../obj/transdec OBJ/transdec test.obj', '../obj/transdec OBJ/transdec test.mtl', function ( object ) {
					object.position.y = -12.975;//experimentally generated via trial and error
					scene2.add( object );//to make a Robosub you would likely need to change it's name from "object"
					transdec2Loaded = true;
					});
//				loader.load('../obj/robosub obstacles/obstacles.obj', function ( object ) {
				loader.load('../obj/robosub obstacles/obstacles.obj', '../obj/robosub obstacles/obstacles.mtl', function ( object ) {
					object.position.y = -12.975;//experimentally generated via trial and error
					scene2.add( object );//to make a Robosub you would likely need to change it's name from "object"
					obstacles2Loaded = true;
					});

				waterNormals = new THREE.ImageUtils.loadTexture( 'textures/waternormals.jpg' ); //potential for easy modification/obstacle reflections
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping; //recycle that .jpg like a TV re-run
				
				waterNormals2 = new THREE.ImageUtils.loadTexture( 'textures/waternormals.jpg' ); //potential for easy modification/obstacle reflections
				waterNormals2.wrapS = waterNormals2.wrapT = THREE.RepeatWrapping; //recycle that .jpg like a TV re-run
				
				waterNormals3 = new THREE.ImageUtils.loadTexture( 'textures/waternormals.jpg' ); //potential for easy modification/obstacle reflections
				waterNormals3.wrapS = waterNormals3.wrapT = THREE.RepeatWrapping; //recycle that .jpg like a TV re-run
				
				
				//initialize/declare water shader and provide parameters
				water = new THREE.Water( renderer, camera, scene, {
					textureWidth: 64, 
					textureHeight: 64,
					waterNormals: waterNormals,
					alpha: 	0.925,
					sunDirection: spotLightRED.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: 0x001e0f,
					distortionScale: 6.25,
					fog: true,
				} );
				water2 = new THREE.Water( renderer2, camera2, scene2, {
					textureWidth: 64, 
					textureHeight: 64,
					waterNormals: waterNormals2,
					alpha: 	0.925,
					sunDirection: spotLightRED.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: 0x001e0f,
					distortionScale: 6.25,
					fog: true,
				} );
				caustic = new THREE.Water( renderer, camera, scene, {
					textureWidth: 32, 
					textureHeight: 32,
					waterNormals: waterNormals3,
					alpha: 	0.125,
					sunDirection: spotLightRED.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: 0xffffff,
					distortionScale: 6.25,
					fog: true,
				} );
				caustic2 = new THREE.Water( renderer2, camera2, scene2, {
					textureWidth: 32, 
					textureHeight: 32,
					waterNormals: waterNormals3,
					alpha: 	0.125,
					sunDirection: spotLightRED.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: 0xffffff,
					distortionScale: 6.25,
					fog: true,
				} );

				/*
				water = new THREE.Water( renderer, camera, scene, { //three.js has a specific thing for water, this is it
					textureWidth: 512, //size of waves I think, maybe the waternormals.jpg stretch?
					textureHeight: 512, //size of waves I think, maybe the waternormals.jpg stretch?
					waterNormals: waterNormals, //provides the .jpg Texture
					alpha: 	0.925, //how transparent is the water?
					//sunDirection: new THREE.Vector3( 0.70707, -0.70707, 0 ), 
					sunDirection: light.position.clone().normalize(), // I think this makes the reflection normal to the texture
					sunColor: 0xffffff, //Light has to hit the water, what color is it?
					waterColor: 0xe7e7ec,//,0x000000,//0x001e0f,//0xe7e7ec,//0x001e0f,//water color for different effects
					distortionScale: 50.0, //also related to size of waves?
					fog: true,
				});
				*/

				//initialize/declare new planes for holding the "water" texture mapping
				mirrorMesh = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( parameters.width * 500, parameters.height * 500 ),
					water.material
				);
				mirrorMesh2 = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( parameters.width * 500, parameters.height * 500 ),
					water.material
				);
				mirrorMeshB = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( parameters.width * 500, parameters.height * 500 ),
					water2.material
				);
				mirrorMeshB2 = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( parameters.width * 500, parameters.height * 500 ),
					water2.material
				);
				mirrorMesh3 = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( parameters.width * 500, parameters.height * 500 ),
					caustic.material
				);
				mirrorMeshB3 = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( parameters.width * 500, parameters.height * 500 ),
					caustic2.material
				);

			
				mirrorMesh.add( water ); //add water shader to otherwise boring underwater PlaneBufferGeometry
				mirrorMesh2.add( water ); //add water shader to otherwise boring PlaneBufferGeometry
				mirrorMesh3.add( caustic ); //add water shader to otherwise boring PlaneBufferGeometry
				
				mirrorMeshB.add( water2 ); //add water shader to otherwise boring underwater PlaneBufferGeometry
				mirrorMeshB2.add( water2 ); //add water shader to otherwise boring PlaneBufferGeometry
				mirrorMeshB3.add( caustic2 ); //add water shader to otherwise boring PlaneBufferGeometry

				
				mirrorMesh.rotation.x = - Math.PI * 1.5; //rotate undwater water surface to point down
				mirrorMesh2.rotation.x = - Math.PI * 0.5; //rotate water surface to point up
				mirrorMesh3.rotation.x = - Math.PI * 0.5; //rotate undwater water surface to point down

				mirrorMeshB.rotation.x = - Math.PI * 1.5; //rotate undwater water surface to point down
				mirrorMeshB2.rotation.x = - Math.PI * 0.5; //rotate water surface to point up
				mirrorMeshB3.rotation.x = - Math.PI * 0.5; //rotate undwater water surface to point down

				mirrorMesh.position.y = -.95;//water height experimentally generated via trial and error
				mirrorMesh2.position.y = -.95;//water height experimentally generated via trial and error
				mirrorMesh3.position.y = -5.65;//water height experimentally generated via trial and error
				
				mirrorMeshB.position.y = -.95;//water height experimentally generated via trial and error
				mirrorMeshB2.position.y = -.95;//water height experimentally generated via trial and error
				mirrorMeshB3.position.y = -5.65;//water height experimentally generated via trial and error

				
				scene.add( mirrorMesh ); //add underwater water surface
				scene.add( mirrorMesh2); //add water surface
				scene.add( mirrorMesh3); //add water surface
				
				scene2.add( mirrorMeshB ); //add underwater water surface
				scene2.add( mirrorMeshB2); //add water surface
				scene2.add( mirrorMeshB3); //add water surface

					///////////////////		
				// CLOUDS VIDEO ///		
				///////////////////		
			
				// create the video element		
				video = document.createElement( 'video' );		
				// video.id = 'video';		
				// video.type = ' video/ogg; codecs="theora, vorbis" ';		
				video.src = "images/clouds.mp4"; //source: https://www.youtube.com/watch?v=Zb3q_zzUSvQ		
				video.loop = true;//alt source: https://www.youtube.com/watch?v=a96UbKNuNQY		
				video.load(); // must call after setting/changing source		
				video.play();		
										
				video2 = document.createElement( 'video' );		
				// video.id = 'video';		
				// video.type = ' video/ogg; codecs="theora, vorbis" ';		
				video2.src = "images/clouds.mp4"; //source: //https://www.youtube.com/watch?v=Zb3q_zzUSvQ		
				video2.loop = true;//alt source: https://www.youtube.com/watch?v=a96UbKNuNQY		
				video2.load(); // must call after setting/changing source		
				video2.play();		
				
				
				// alternative method -- 		
				// create DIV in HTML:		
				// <video id="myVideo" autoplay style="display:none">		
				//		<source src="videos/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>		
				// </video>		
				// and set JS variable:		
				// video = document.getElementById( 'myVideo' );		
			
				videoImage = document.createElement( 'canvas' );		
				videoImage.width = 640;		
				videoImage.height = 480;		
				videoImage2 = document.createElement( 'canvas' );		
				videoImage2.width = 480;		
				videoImage2.height = 480;		
				videoImageContext = videoImage.getContext( '2d' );		
				// background color if no video present		
				videoImageContext.fillStyle = '#000000';		
				videoImageContext.fillRect( 0, 0, videoImage.width, videoImage.height );		
				videoImageContext2 = videoImage2.getContext( '2d' );		
				// background color if no video present		
				videoImageContext2.fillStyle = '#000000';		
				videoImageContext2.fillRect( 0, 0, videoImage2.width, videoImage2.height );		
				videoTexture = new THREE.Texture( videoImage );		
				videoTexture.minFilter = THREE.LinearFilter;		
				videoTexture.magFilter = THREE.LinearFilter;		
						
				videoTexture2 = new THREE.Texture( videoImage2 );		
				videoTexture2.minFilter = THREE.LinearFilter;		
				videoTexture2.magFilter = THREE.LinearFilter;		
			
				var movieMaterial = new THREE.MeshBasicMaterial( { map: videoTexture, overdraw: true, side:THREE.DoubleSide } );		
				var movieMaterial2 = new THREE.MeshBasicMaterial( { map: videoTexture2, overdraw: true, side:THREE.DoubleSide } );
				
				// load skybox &/or (start example code copypasta: http://threejs.org/examples/#webgl_shaders_ocean)
				var cubeMap = new THREE.CubeTexture( [] );//initialize/declare the texture object to be mapped to the skybox mesh var skyBox = new THREE.Mesh
				cubeMap.format = THREE.RGBFormat;//don't know what this does, appears to be a type declaration?
				cubeMap.flipY = false;//if you make this true the walls of the box go below the horizon
				
				var cubeMap2 = new THREE.CubeTexture( [] );//initialize/declare the texture object to be mapped to the skybox mesh var skyBox = new THREE.Mesh
				cubeMap2.format = THREE.RGBFormat;//don't know what this does, appears to be a type declaration?
				cubeMap2.flipY = false;//if you make this true the walls of the box go below the horizon
				
				var loader = new THREE.ImageLoader();
				loader.load( '../textures/skyboxsun25degtest.png', function ( image ) {
					var getSide = function ( x, y ) {
						var size = 1024;
						var canvas = document.createElement( 'canvas' );
						canvas.width = size;
						canvas.height = size;
						var context = canvas.getContext( '2d' );
						context.drawImage( image, - x * size, - y * size );
						return canvas;
					};
					cubeMap.images[ 0 ] = getSide( 2, 1 ); // px
					cubeMap.images[ 1 ] = getSide( 0, 1 ); // nx
					cubeMap.images[ 2 ] = getSide( 1, 0 ); // py
					cubeMap.images[ 3 ] = getSide( 1, 2 ); // ny
					cubeMap.images[ 4 ] = getSide( 1, 1 ); // pz
					cubeMap.images[ 5 ] = getSide( 3, 1 ); // nz
					cubeMap.needsUpdate = true;
				} );

				var loader2 = new THREE.ImageLoader();
				loader2.load( '../textures/skyboxsun25degtest.png', function ( image ) {
					var getSide = function ( x, y ) {
						var size = 1024;
						var canvas = document.createElement( 'canvas' );
						canvas.width = size;
						canvas.height = size;
						var context = canvas.getContext( '2d' );
						context.drawImage( image, - x * size, - y * size );
						return canvas;
					};
					cubeMap2.images[ 0 ] = getSide( 2, 1 ); // px
					cubeMap2.images[ 1 ] = getSide( 0, 1 ); // nx
					cubeMap2.images[ 2 ] = getSide( 1, 0 ); // py
					cubeMap2.images[ 3 ] = getSide( 1, 2 ); // ny
					cubeMap2.images[ 4 ] = getSide( 1, 1 ); // pz
					cubeMap2.images[ 5 ] = getSide( 3, 1 ); // nz
					cubeMap2.needsUpdate = true;
				} );


				var cubeShader = THREE.ShaderLib['cube'];
				cubeShader.uniforms['tCube'].value = cubeMap;
				
				var cubeShader2 = THREE.ShaderLib['cube'];
				cubeShader2.uniforms['tCube'].value = cubeMap2;

				//Create skybox material 
				var skyBoxMaterial = new THREE.ShaderMaterial( {
					fragmentShader: cubeShader.fragmentShader,
					vertexShader: cubeShader.vertexShader,
					uniforms: cubeShader.uniforms,
					depthWrite: false,
					//fog: true, //To Do: make a derived shade which has been modified for "fog"
					side: THREE.BackSide
				});
				
				var skyBoxMaterial2 = new THREE.ShaderMaterial( {
					fragmentShader: cubeShader2.fragmentShader,
					vertexShader: cubeShader2.vertexShader,
					uniforms: cubeShader2.uniforms,
					depthWrite: false,
					//fog: true, //To Do: make a derived shade which has been modified for "fog"
					side: THREE.BackSide
				});
				
				//Create Mesh to map skybox material on to
				skyBox = new THREE.Mesh(
					new THREE.BoxGeometry( 10000, 10000, 10000 ),
					movieMaterial
				);
				skyBox.rotation.y += Math.PI/6;		
				skyBox2 = new THREE.Mesh(
					new THREE.BoxGeometry( 10000, 10000, 10000 ),
					movieMaterial2
				);
				skyBox2.rotation.y += Math.PI/6;		
				scene.add( skyBox ); //create Point Loma Sky
				scene2.add( skyBox2 ); //create Point Loma Sky


				var geometry = new THREE.IcosahedronGeometry( 30, 4 );
				for ( var i = 0, j = geometry.faces.length; i < j; i ++ ) {
					geometry.faces[ i ].color.setHex( 0xffffff );
				}
				var material = new THREE.MeshPhongMaterial( {
					vertexColors: THREE.FaceColors,
					shininess: 100000,
					envMap: cubeMap
				} );
				sphere = new THREE.Mesh( geometry, material );
				scene.add( sphere );
				
				var geometry2 = new THREE.IcosahedronGeometry( 10, 4 );
				for ( var i = 0, j = geometry.faces.length; i < j; i ++ ) {
					geometry.faces[ i ].color.setHex( 0xffff00 );
				}
				var material2 = new THREE.MeshPhongMaterial( {
					vertexColors: THREE.FaceColors,
					shininess: 100,
					envMap: cubeMap
				} );
				sphere2 = new THREE.Mesh( geometry2, material2 );
				//scene.add( sphere2 );
				
			}
			//source: This entire "init()" function is very "boilerplate" from the examples at http://threejs.org/examples/ covered under the MIT License
			//attribution: Please see the "MIT License" included in this document

			//source: This code no longer appears to contain anything that belongs to http://www.smartjava.org/ltjs/chapter-09/02-selecting-objects.html
			var guivalues = new function () {
					
				    this.timeShift = 0;
				    this.cameraNear = camera.near;
				    this.cameraFar = camera.far;
				    this.saveimage = function(){
					if(record && transdecLoaded && transdec2Loaded && obstaclesLoaded && obstacles2Loaded){
					imagenumber++;
					console.log("Mouse x: " + camControls.mouseX.toString() + " Mouse y:" + camControls.mouseY.toString() );
					//this.randomVis();
					filename1 = "testfwd" + String.fromCharCode(imageletter) + imagenumber.toString() + ".png"
					filename2 = "testdwn" + String.fromCharCode(imageletter) + imagenumber.toString() + ".png"
					this.saveimage1();
					this.saveimage2();
					console.log(["filename1", "filename2", "position.x", "position.y", "position.z", "rotation.y","mousex","mousey","W","A","S","D","validationgatePoints","pathmarker1Points","buoy1Points","buoy1Backup","buoy2Points","buoy2Backup","buoy3Points","pathmarker2Points","maneuverPoints","pathmarker3Points","pathmarker4Points","pathmarker5Points","octagon1Points","pathmarker6Points","pathmarker7Points","octagon2Points"]);
					console.log([filename1, filename2, camera.position.x.toString(), camera.position.y.toString(), camera.position.z.toString(), camera.rotation.y.toString(), camControls.mouseX.toString(), camControls.mouseY.toString(), keyboard.pressed("W"), keyboard.pressed("A"), keyboard.pressed("S"), keyboard.pressed("D"),validationgatePoints,pathmarker1Points,buoy1Points,buoy1Backup,buoy2Points,buoy2Backup,buoy3Points,pathmarker2Points,maneuverPoints,pathmarker3Points,pathmarker4Points,pathmarker5Points,octagon1Points,pathmarker6Points,pathmarker7Points,octagon2Points]); 
					//if(record){data.push([filename1, filename2, camera.position.x.toString(), camera.position.y.toString(), camera.position.z.toString(), camera.rotation.y.toString(), camControls.mouseX.toString(), camControls.mouseY.toString(), camControls.autoForward, keyboard.pressed("A"), camControls.autoBackward, keyboard.pressed("D"),validationgatePoints,pathmarker1Points,buoy1Points,buoy1Backup,buoy2Points,buoy2Backup,buoy3Points,pathmarker2Points,maneuverPoints,pathmarker3Points,pathmarker4Points,pathmarker5Points,octagon1Points,pathmarker6Points,pathmarker7Points,octagon2Points]);}
					//data = [["filename1", "filename2", "position.x", "position.y", "position.z", "rotation.z"], ["fwda00001.png", "dwna00001.png", "0", "0", "0", "3"]];
					if(record){data.push([filename1, filename2, camera.position.x.toString(), camera.position.y.toString(), camera.position.z.toString(), camera.rotation.y.toString(), camControls.mouseX.toString(), camControls.mouseY.toString(), keyboard.pressed("W"), keyboard.pressed("A"), keyboard.pressed("S"), keyboard.pressed("D"),validationgatePoints,pathmarker1Points,buoy1Points,buoy1Backup,buoy2Points,buoy2Backup,buoy3Points,pathmarker2Points,maneuverPoints,pathmarker3Points,pathmarker4Points,pathmarker5Points,octagon1Points,pathmarker6Points,pathmarker7Points,octagon2Points]);}
					this.savetext("labels" + String.fromCharCode(imageletter) + imagenumber.toString());
					if(maneuverPoints && savecsv1){
						//imagenumber = 0; 
						//imageletter++; 
						//this.savetext("maneuversave");
						audio.play();
						savecsv1 = false;
					}}
				    };
			            this.saveimage1 = function(){
					var b = document.createElement('a');
					var extra_canvas = document.createElement("canvas");
        				extra_canvas.setAttribute('width', 167);
        				extra_canvas.setAttribute('height', 80);
        				var ctx = extra_canvas.getContext('2d');
					var img = new Image();
					img.onload = function(){
    						ctx.drawImage(img, 0, 0, 167, 80);
						b.href = extra_canvas.toDataURL('image/png');
						b.download = filename1;
						b.target = '_self';
						b.style.display = 'none';
						// This step is needed for this to function in Firefox.
						document.body.appendChild(b);
						b.click();
					};
					img.src = renderer.domElement.toDataURL("image/png");
				    };
			            this.saveimage2 = function(){
					var b = document.createElement('a');
					//var filename = 'test.png';
					//console.log(renderer2.domElement.toDataURL("image/png"));
					b.href = renderer2.domElement.toDataURL("image/png");
					b.download = filename2;
					b.target = '_self';
					b.style.display = 'none';
					// This step is needed for this to function in Firefox.
					document.body.appendChild(b);
					b.click();
				    };
				    this.savetext = function(filename3){
					    
					    //var data = [["filename1", "filename2", "position.x", "position.y", "position.z", "rotation.z"], ["fwda00001.png", "dwna00001.png", "0", "0", "0", "3"]];
					    csvContent = "data:text/csv;charset=utf-8,";
				            data.forEach(function(infoArray, index){
						    dataString = infoArray.join(",");
   					    	    csvContent += index < data.length ? dataString+ "\n" : dataString;
					    }); 
					    var encodedUri = encodeURI(csvContent);
					    var link = document.createElement("a");
					    link.setAttribute("href", encodedUri);
					    //link.setAttribute("download", "my_data.csv");
					    link.setAttribute("download", filename3 + ".csv");
					    document.body.appendChild(link); // Required for FF
					    link.click();
				    }
				    this.getLostBoth = function(){
				    	camera.position.x = (Math.random() * 90.0);
				    	camera.position.x -=45.0;
				    	camera.position.y = ((Math.random() * -4.55) - 0.95);
				    	camera.position.z = (Math.random() * 60.0);
				    	camera.position.z -= 30.0;
       				    	camera.rotation.y = (Math.random() * (Math.PI*2.0));
       				    	camera.rotation.y -= Math.PI;
				    };
				    this.getLostComp = function(){
					camControls.mouseX = ((Math.random() * 4900)+100);
				    	camera.position.x = (Math.random() * -45.0);
				    	camera.position.y = ((Math.random() * -4.55) - 0.95);
				    	camera.position.z = (Math.random() * 60.0);
				    	camera.position.z -= 30.0;
       				    	//camera2.rotation.y += (Math.random() * (Math.PI*2.0));
       				    	//camera2.rotation.y -= Math.PI;
       				    	//camera.rotation.y = camera2.rotation.y;
					this.randomVis();
					this.saveimage();
				    };
				    this.getLostPract = function(){
				    	camControls.mouseX = ((Math.random() * 4900)+100);
				    	camera.position.x = (Math.random() * 45.0);
				    	camera.position.y = ((Math.random() * -4.55) - 0.95);
				    	camera.position.z = (Math.random() * 60.0);
				    	camera.position.z -= 30.0;
       				    	//camera.rotation.y = (Math.random() * (Math.PI*2.0));
       				    	//camera.rotation.y -= Math.PI;
					this.randomVis();
					this.saveimage();
				    };
				    this.lookAtRedBuoy = function(){
				    	camera.position.x = -23.14 + ((Math.random() * 10.0) - 5.0);
				    	camera.position.y = -2.2;// + ((Math.random() * 1.0) - 0.5);
				    	camera.position.z = -21.74 + ((Math.random() * 10.0) - 5.0);
				    	//camera3.position.copy(camera);
				    	camera3.position.x =-23.14;
				    	camera3.position.y = -2.2
				    	camera3.position.z = -21.74;
				    	
				    	
				    	//camera.lookAt(-23.14,-2.2,-21.74);
				    	//camera2.lookAt(camera3);
				    	//camera.rotation.z = camera3.rotation.z;

       				    	//camera.rotation.z = (Math.random() * (Math.PI*2.0));
       				    	//camera.rotation.z -= Math.PI;
				    };
				    this.lookAtYellowBuoy = function(){
				    	camera.position.x = -22.44 + ((Math.random() * 10.0) - 5.0);
				    	camera.position.y = -2.15;// + ((Math.random() * 1.0) - 0.5);
				    	camera.position.z = -20.69 + ((Math.random() * 10.0) - 5.0);
				    	//camera3.position.copy(camera);
				    	//camera.lookAt(-22.44,-2.15,-20.69);
				    	//camera.rotation.z = camera3.rotation.z;

       				    	//camera.z = (Math.random() * (Math.PI*2.0));
       				    	//camera.rotation.z -= Math.PI;
				    };
				    this.lookAtGreenBuoy = function(){
				    	camera.position.x = -21.8 + ((Math.random() * 10.0) - 5.0);
				    	camera.position.y = -2.05;// + ((Math.random() * 1.0) - 0.5);
				    	camera.position.z = -19.65 + ((Math.random() * 10.0) - 5.0);
				    	//camera3.position.copy(camera);
				    	//camera.lookAt(-21.8,-2.05,-19.65);
				    	//camera.rotation.z = camera3.rotation.z;

       				    	//camera.rotation.z = (Math.random() * (Math.PI*2.0));
       				    	//camera.rotation.z -= Math.PI;
				    };
				    this.lightDepthFix = function(){
					intensity = .85;
					depthcm = (camera2.position.y + (0.9)) * (-100.0);
					adjIntensityRED = (intensity * (Math.exp(-.006 * depthcm)));
					adjIntensityGREEN = (intensity * (Math.exp(-.00032 * depthcm)));
					adjIntensityBLUE = (intensity * (Math.exp(-.000247 * depthcm)));
					spotLightRED.intensity = adjIntensityRED;
					spotLightRED2.intensity = adjIntensityRED;
					spotLightGREEN.intensity = adjIntensityGREEN;
					spotLightGREEN2.intensity = adjIntensityGREEN;
					spotLightBLUE.intensity = adjIntensityBLUE;
					spotLightBLUE2.intensity = adjIntensityBLUE;
				    };
				    this.normalLight = function(){
					var nintensity = 0.85;
					var nintensity1 = .95;
					var nintensity2 = .25;
					var nintensity3 = .375;
					
					spotLightRED.intensity = nintensity;
					spotLightRED2.intensity = nintensity;
					spotLightGREEN.intensity = nintensity;
					spotLightGREEN2.intensity = nintensity;
					spotLightBLUE.intensity = nintensity;
					spotLightBLUE2.intensity = nintensity;
					
					lightRed.intensity = nintensity2;
					light2Red.intensity = nintensity2;
					lightGreen.intensity = nintensity2;
					light2Green.intensity = nintensity2;
					lightBlue.intensity = nintensity2;
					light2Blue.intensity = nintensity2;

					//ambient light set
					ambientLightRed.intensity = nintensity3;
					ambientLight2Red.intensity = nintensity3;
					ambientLightGreen.intensity = nintensity3;
					ambientLight2Green.intensity = nintensity3;
					ambientLightBlue.intensity = nintensity3;
					ambientLight2Blue.intensity = nintensity3;

				    	//scene.spotLight.intensity = (Math.random() * 5.0);
				    	//scene2.spotLight2.intensity = (Math.random() * 5.0);
				    };
				    this.resetGame = function(){
					victoryCounter++;
					resetfilename = "run" + victoryCounter + ".csv";
					//this.savetext(resetfilename);
					console.log(resetfilename);
					var fogintensityrandom = ((Math.random() * 0.0225)-0.0225);
					//var newMoveSpeed = (Math.random() * 3.75);
				        scene.fog = new THREE.FogExp2( 0x008080, 0.1275 + fogintensityrandom );
				        scene2.fog = new THREE.FogExp2( 0x008080, 0.1275 + fogintensityrandom );
					//camControls.movementSpeed = 0.25+newMoveSpeed;
					//camControls2.movementSpeed = 0.25+newMoveSpeed;
					//"you just beat the game" code goes here
					pathmarker1Points = false;
					pathmarker2Points = false;
					pathmarker3Points = false;
					pathmarker4Points = false;
					pathmarker5Points = false;
					pathmarker6Points = false;
					pathmarker7Points = false;
					octagon1Points = false;
					octagon2Points = false;
					octagon1Center = false;
      					octagon2Center = false;
				        octagon1Done = false;
					octagon2Done = false;
					buoy1Points = false;
					buoy2Points = false;
					buoy1Backup = false;
					buoy2Backup = false;
					buoy3Points = false;
					validationgatePoints = true;
					maneuverPoints = false;
					var randposx = (-2.5 + (Math.random()*2.0)-1.0);
					var randposy = -2.0;
					var randposz = (-26.0 + (Math.random()*2.0)-1.0);
					camera.position.x = randposx;//pool line of symetry is x axis
					camera.position.y = randposy;//water depth
					camera.position.z = randposz;//how close to the wall are you
					data = [["filename1", "filename2", "position.x", "position.y", "position.z", "rotation.y","mousex","mousey","W","A","S","D","validationgatePoints","pathmarker1Points","buoy1Points","buoy1Backup","buoy2Points","buoy2Backup","buoy3Points","pathmarker2Points","maneuverPoints","pathmarker3Points","pathmarker4Points","pathmarker5Points","octagon1Points","pathmarker6Points","pathmarker7Points","octagon2Points"]];	
			
			
				    }
				    this.bumpPos = function(){
				    	var randposx = (camera.position.x + (Math.random()*2.0)-1.0);
					var randposy = (camera.position.y - Math.random());
					var randposz = (camera.position.z + (Math.random()*2.0)-1.0);
					camera.position.x = randposx;//pool line of symetry is x axis
					camera.position.y = randposy;//water depth
					camera.position.z = randposz;//how close to the wall are you
					}
				    this.randomVis = function(){
				    	fdensity = (Math.random() * .75);
					scene.fog.density = fdensity;
					scene2.fog.density = fdensity;
				    	
					rintensity = (Math.random() * 0.6667);
					
					spotLightRED.intensity = rintensity;
					spotLightRED2.intensity = rintensity;
					spotLightGREEN.intensity = rintensity;
					spotLightGREEN2.intensity = rintensity;
					spotLightBLUE.intensity = rintensity;
					spotLightBLUE2.intensity = rintensity;

				    };
				}
			//source: This code no longer appears to contain anything that belongs to http://www.smartjava.org/ltjs/chapter-09/02-selecting-objects.html
				shaderParams = {
					binaryThreshold:true,
				}
				
			//source: This code no longer appears to contain anything that belongs to http://nuevil.com/index3.html
			var gui = new dat.GUI({resizable : false});
			gui.add(shaderParams, 'binaryThreshold').onChange(onToggleShaders);

			gui.add(guivalues, 'cameraNear', 0, 25).onChange(function (e) {
        		    camera.near = e;
        		});
        		gui.add(guivalues, 'cameraFar', 10, 25).onChange(function (e) {
        			camera.far = e;
        		});
			var folder1 = gui.addFolder('visibility');
			var fogDensity = folder1.add(scene2.fog, 'density').min(0.00).max(0.75).step(0.01).listen();
			//var cameraNear = 
			
			var lightIntensity = folder1.add(spotLightRED, 'intensity').min(0.00).max(2.0).step(0.01).listen();
			var timeOfDay = folder1.add(guivalues, 'timeShift').min(-6.0).max(6.0).step(0.01).listen();
			var folder2 = gui.addFolder('behavior');
			var rotSpeed = folder2.add(camControls2, 'lookSpeed').min(0.0).max(0.5).step(0.01).listen();
			var movSpeed = folder2.add(camControls2, 'movementSpeed').min(0.0).max(5.0).step(0.01).listen();
			var folder3 = gui.addFolder('position');
  			var posX = folder3.add( camera2.position, 'x' ).min(-50.00).max(50.00).step(0.01).listen();
  			var posY = folder3.add( camera2.position, 'y' ).min(-50.00).max(50.00).step(0.01).listen();
  			var posZ = folder3.add( camera2.position, 'z' ).min(-50.00).max(50.00).step(0.01).listen();
  			var folder4 = gui.addFolder('rotation');
  			var rotY = folder4.add( camera.rotation, 'y' ).min(-1.58).max(1.58).step(0.01).listen();
  			var folder5 = gui.addFolder('confusion');
  			var rVis = gui.add(guivalues, 'randomVis');
  			var rPosHead = gui.add(guivalues, 'getLostBoth');
  			var rPosHeadComp = gui.add(guivalues, 'getLostComp');
  			var rPosHeadPract = gui.add(guivalues, 'getLostPract');
  			//source: This code no longer appears to contain anything that belongs to http://nuevil.com/index3.html

  			posX.onChange( function(value){   camera2.position.x = value; camera.position.x = value;   } );
  			posY.onChange( function(value){   camera2.position.y = value; camera.position.y = value;   } );
			posZ.onChange( function(value){   camera2.position.z = value; camera.position.z = value;   } );
			rotY.onChange( function(value){   camera.rotation.y = value; camera2.rotation.y = value;   } );
			//source:http://nuevil.com/index3.html

			//source: This code no longer appears to contain anything that belongs to Rudie Dirkx http://hotblocks.nl/tests/three/dat.gui.html 
			fogDensity.onChange( function(value){   scene2.fog.density = value; scene.fog.density = value;   });
  			rotSpeed.onChange( function(value){   camControls2.lookSpeed = value; camControls.lookSpeed = value;   });
			movSpeed.onChange( function(value){   camControls2.movementSpeed = value; camControls.movementSpeed = value;  });
			lightIntensity.onChange( function(value){   spotLightRED2.intensity = value; spotLightRED.intensity = value;   });
			timeOfDay.onChange( function(value){   guivalues.timeShift = value; });
			//source: This code no longer appears to contain anything that belongs to Rudie Dirkx http://hotblocks.nl/tests/three/dat.gui.html 

			//source: MIT License OR "This code no longer appears to contain anything that belongs to josdirksen?"
			/*
			* Returns member of set with a given mean and standard deviation
			* mean: mean
			* standard deviation: std_dev 
			*/
			function createMemberInNormalDistribution(mean,std_dev){
				return mean + (gaussRandom()*std_dev);
			}

			/*
			* Returns random number in normal distribution centering on 0.
			* ~95% of numbers returned should fall between -2 and 2
			*/
			function gaussRandom() {
				var u = 2*Math.random()-1;
				var v = 2*Math.random()-1;
				var r = u*u + v*v;
				/*if outside interval [0,1] start over*/
				if(r == 0 || r > 1) return gaussRandom();

				var c = Math.sqrt(-2*Math.log(r)/r);
				return u*c;

				/* todo: optimize this algorithm by caching (v*c) 
				 * and returning next time gaussRandom() is called.
				 * left out for simplicity */
			}
	
			function onToggleShaders() {
				composer = new THREE.EffectComposer( renderer);
				//Add Shader Passes to Composer
				composer.addPass( renderPass );
				if (shaderParams.binaryThreshold){
					composer.addPass( brightnessContrastPass );
				}
				composer.addPass( copyPass );
				//set last pass in composer chain to renderToScreen
				copyPass.renderToScreen = true;
			}
			
			function animate() {
				requestAnimationFrame( animate ); //animate the frame
				if(!record){render();} //render the frame
				
				//////////////////comment out the line below for websocket controlled rendering///////////
				if(record){render();} //render the frame
				//////////////////comment out the line below for websocket controlled rendering///////////
				
				
				//if(runonce){render(); runonce = false;}
				//composer.render();
				}
			//source: MIT License OR "This code no longer appears to contain anything that belongs to josdirksen?"

			//source: MIT License OR "This code no longer appears to contain anything that belongs to josdirksen?"
			function render() {
				keyboard.update();
				var lastTargetDistance = Math.pow((Math.pow((camera2.position.x-targetx),2)+Math.pow((camera2.position.y-targety),2)+Math.pow((camera2.position.z-targetz),2)),0.5);
				var reward = 0;
				onmousemove = function(e){mouseposx = e.clientX; mouseposy = e.clientY; mousething = true;}// guivalues.savetext();}
				
				var time = performance.now() * 0.001; //Measure time for water
				/* //periodic noise
				camera.position.y += .00175;
				camera.position.y += Math.sin( time ) * .00125;
				camera.position.y += Math.sin( time * .75 ) * .00125;
				camera.position.x += Math.sin( time * .99 ) * .001875 * 0.5;
				camera.position.x += Math.sin( time * .74 ) * .001875 * 0.5;
				camera.position.z += Math.sin( time * 1.01) * .001875 * 0.5;
				camera.position.z += Math.sin( time * .76 ) * .001875 * 0.5;
				camera.rotation.y += Math.sin( time ) * .00125 * 5;
				camera.rotation.y += Math.sin( time * .25 ) * .00125 * 5;
				camera.translateX(Math.sin( time * .99 ) * .001875 * 0.25);
				camera.translateX(Math.sin( time * .74 ) * .001875 * 0.25);
				camera.translateZ(Math.sin( time * 1.01) * .001875 * 0.25);
				camera.translateZ(Math.sin( time * .76 ) * .001875 * 0.25);
				*/
				
				// Teleport noise / "got lost" noise
				/*if(Math.random()>=0.995){
					camera.position.y += (Math.random()*0.5 - 0.25);
					camera.position.x += (Math.random()*2 - 1);
					camera.position.z += (Math.random()*2 - 1);
				}*/
				// Teleport noise / "got lost" noise
				
				camControls.update( clock.getDelta() ); //update First Person Camera
				camControls2.update( clock.getDelta() ); //update First Person Camera
				camera2.position.copy( camera.position );
				camera2.rotation.copy( camera.rotation );
				//camera2.rotation.z = camera3.rotation.z;
				camera2.up = new THREE.Vector3(-1,-1,-1);
				camera2.rotateX(Math.PI/-2);
				camera2.rotateZ((Math.PI/-2));
				camera2.rotateZ(Math.PI/2);
				if ( video.readyState === video.HAVE_ENOUGH_DATA ) 		
				{		
					//video.play();		
					videoImageContext.drawImage( video, 0, 0 );		
					skyBox.rotation.y += Math.PI/180;		
					if ( videoTexture ) 		
						videoTexture.needsUpdate = true;		
				}		
			
				if ( video2.readyState === video2.HAVE_ENOUGH_DATA ) 		
				{			
					//video.play();		
					//skyBox2.rotation.y += Math.PI/180;		
					videoImageContext2.drawImage( video2, 0, 0 );		
					if ( videoTexture2 ) 		
						videoTexture2.needsUpdate = true;		
				}
				//camera3.position.x =-23.14;
				//camera3.position.y = -2.2
				//camera3.position.z = -21.74;
				
				//camera.lookAt(camera3);
				//camera2.lookAt(camera3);
				//if (1==1){guivalues.lightDepthFix();}
				
				
				//real time 24 hour day
				//var timeSolar = performance.now() * 0.000000003472 + 32470000 + 3 * 3600000; //Measure time for sun
				//rapid time for testing
				timeSolar = performance.now() * 0.00000003472 * 36000; //Measure time for sun
				
				
				if ( !pathmarker1Points ) {
						targetx = -15.77;
						targetz = -22.13;
					}else { 
							if ( !buoy1Points ) {
									targetx = -21.79;
									targetz = -19.64;
									targety = -2.03;
									console.log("current target: buoy1");
								}else { 
										//guivalues.resetGame();
										if ( !buoy1Backup ) {
												buoy1Backup = true;
												//drivereverse = true;
												//targetx = -15.77;
												//targetz = -19.74;
												//camera.position.x = -15.77;
												//camera.position.z = -24.64;
												//camera2.position.x = -15.77;
												//camera2.position.z = -24.64;
												console.log("current target: buoy1");
											}else {
													if ( !buoy2Points ) {
															targetx = -22.47;
															targetz = -20.69;
															targety = -2.12;
															console.log("current target: buoy2");
														}else {
																if ( !buoy2Backup ) {
																		//drivereverse = true;
																		//targetx = -18.77;																																				//camera.position.x = -15.77;
																		//targetz = -18.64;

																		buoy2Backup = true;
																		//camera.position.x = -15.77;
																		//camera.position.z = -24.64;
																		//camera2.position.x = -15.77;
																		//camera2.position.z = -25.64;
																		console.log("current target: buoy2");
																	}else {
																			if ( !buoy3Points ) {
																					drivereverse = false;
																					targetx = -23.14;
																					targetz = -21.71;
																					targety = -2.2;
																					console.log("current target: buoy3");
																				}else {
																						if ( !pathmarker2Points ) {
																								targetx =  -24.76;
																								targetz = -19.34;
																								console.log("current target: pathmarker2");
																							}else {
																									if ( !pathmarker3Points ) {
																											targetx = -24.7;
																											targetz = -19.41;
																											console.log("current target: pathmarker3");
																										}else { 
																												if ( !maneuverPoints ) {
																														targetx = -29.55;
																														targetz = -13.73;
																														targety = -1.85;
																														console.log("current target: maneuver");
																													}else {
																															if ( !pathmarker4Points ) {
																																targetx = -29.85;
																																targetz = -11.79;
																																console.log("current target: pathmarker4");
																															}else {
																																	if ( !pathmarker5Points ) {
																																		targetx = -31.29;
																																		targetz = 1.86;
																																		console.log("current target: pathmarker5");
																																	}else {
																																			if ( !pathmarker6Points ) {
																																				targetx = -29.57;
																																				targetz = 12.44;
																																				targety = -3.5;
																																				console.log("current target: pathmarker6");
																																			}else {
																																					if(autopilotrun){guivalues.resetGame();}
																																					if ( !octagon1Center ) {
																																						targetx = -32.96;
																																						targetz = 12.05;
																																						console.log("current target: octagon1 center");
																																						}else {
																																								if ( !octagon1Points ) {
																																									targety = -1.04;
																																									console.log("current target: octagon1");
																																								}else {
																																										if ( !octagon1Done ) {
																																											targety = -3.25;
																																											console.log("current target: octagon1 dive");
																																											}else {
																																												if ( !pathmarker7Points ) {
																																													targetx = -23.57;
																																													targetz = 15.41;
																																													console.log("current target: pathmarker7");
																																												}else {
																																														if ( !octagon2Center ) {
																																															targetx = -21.08;
																																															targetz = 17.98;
																																															console.log("current target: octagon2 center");
																																														}else {
																																																if ( !octagon2Points ) {
																																																	targety = -1.04;
																																																	console.log("current target: octagon1");
																																																}else {
																																																	guivalues.savetext(resetfilename);
																																																	guivalues.resetGame();
																																																}}}}}}}}}}}}}}}}}}																	
														
				var newdistancetotarget = Math.pow((Math.pow((camera2.position.x-targetx),2)+Math.pow((camera2.position.y-targety),2)+Math.pow((camera2.position.z-targetz),2)),0.5);

				deltatargetvelocity = lastTargetDistance - newdistancetotarget;
				
				if ((-.00021288497260888326)*(Math.abs(Math.pow(camera.position.x,3)))+(-.0038646361243415903)*(Math.pow(camera.position.x,2))+(-.044978127733920653)*(Math.abs(camera.position.x))+(30.78479999999999851)-(camera.position.z) < 2.0) {
				//camera.position.x = oldcamerax; 
				//camera.position.z = oldcameraz; 
				//camera2.position.x = oldcamerax2; 
				//camera2.position.z = oldcameraz2; 
				reward = -1.0; 
				reward -= 1.95;
				camera.position.z -= 0.251; 
				camera2.position.z -= 0.251;
				}
				if (((((-.00021288497260888326)*(Math.abs(Math.pow(camera.position.x,3)))+(-.0038646361243415903)*(Math.pow(camera.position.x,2))+(-.044978127733920653)*(Math.abs(camera.position.x))+(0.30479999999999851))*-1.0)-30.480)-(camera.position.z) > -3.0) {
				//camera.position.x = oldcamerax; 
				//camera.position.z = oldcameraz; 
				//camera2.position.x = oldcamerax2; 
				//camera2.position.z = oldcameraz2; 
				reward = -1.0; 
				reward -= 1.95; 
				camera.position.z += 0.251; 
				camera2.position.z += 0.251;
				}
				
				//targetYaw = Math.atan2( (camera.position.z - targetz) , (camera.position.x - targetx) );
				//this chunk of code addresses the the asymptotic behavior of arctan when x = 0;
				//http://stackoverflow.com/a/3309658
				if ( targetz-camera.position.z > 0.001 || targetz-camera.position.z < -0.001 )
					{
						targetYaw = Math.atan2( -1*( targetx - camera.position.x ), ( targetz - camera.position.z) );
					} else{
						if(previousDeltaZ !=0){targetYaw = Math.atan2( -1*( targetx - camera.position.x ), ( previousDeltaZ ));};
					}
				//this chunk of code addresses the the asymptotic behavior of arctan when x = 0;
				targetYaw = (1.0*targetYaw) % (Math.PI*2);
				//if(targetYaw > Math.PI){targetYaw -= Math.PI; targetYaw = -1.0*targetYaw; }				
				//targetYaw = (-1.0*targetYaw) % (Math.PI/2);
				
				//the code modeled by the neural network
				var currentYaw = camera.rotation.y;
				var errorYaw = targetYaw - currentYaw;
				
				if(!drivereverse){integralYaw += errorYaw;}
				var derivativeYaw = (errorYaw - previouserrorYaw);
				var outputYaw = (globalyawKp*errorYaw) + (globalyawKi*integralYaw) + (globalyawKd*derivativeYaw);
				previouserrorYaw = errorYaw;
				previousDeltaZ = (targetz-camera.position.z);
				//if(drivereverse){camControls.mouseX  = -1.0*outputYaw;}
				//}else{
				if(autopilotrun){camControls.mouseX  = outputYaw;}
				//if(!drivereverse && (Math.pow((Math.pow((camera2.position.x-targetx),2)+Math.pow((camera2.position.y-targety),2)+Math.pow((camera2.position.z-targetz),2)),0.5)>5.0)){camControls.mouseX  = outputYaw;}//else{camControls.mouseX = 0;}
				//}
				//}
				//console.log("currentYaw: " + currentYaw + " targetYaw: " + targetYaw + " errorYaw: " + errorYaw + " outputYaw: " + outputYaw + " mouseX: " + camControls.mouseX);	
				console.log(newdistancetotarget);
				var depthKp = 100; var depthKi = 0.00001; var depthKd = 0.000000001;
				var currentDepth = camera.position.y;
				var errorDepth = targety - currentDepth;
				integralDepth += errorDepth;
				var derivativeDepth = (errorDepth - previouserrorDepth);
				var outputDepth = (depthKp*errorDepth) - (depthKi*integralDepth) + (depthKd*derivativeDepth);
				previouserrorDepth = errorDepth;
				if(autopilotrun){camControls.mouseY  = -1*outputDepth;}
				console.log("currentDepth: " + currentDepth + " targetYaw: " + targety + " errorDepth: " + errorDepth + " outputDepth: " + outputDepth + " mouseY: " + camControls.mouseY);	
                                /*
					if(!drivereverse){
						if( (Math.abs(outputYaw) < 1) && (Math.abs(errorYaw)<0.02)  && transdecLoaded && transdec2Loaded && obstaclesLoaded && obstacles2Loaded){
							autoForward = true;
							autoBackward = false;
							camControls.moveBackward = false;
							camControls2.moveBackward = false;

					
							camControls.moveForward = true;
							camControls2.moveForward = true;
							if(record) {guivalues.saveimage();}
							//reward += 0.001; 
							console.log("GOOD! movForeward towards target!");
						}else{
							//var moveSpeed = ((camControls2.movementSpeed / Math.abs(errorYaw)) * (newdistancetotarget/20)) + 0.15 ;
							//var lookSpeed = (camControls2.lookSpeed / Math.abs(errorYaw));
							//camControls2.movementSpeed = moveSpeed; //0.25;//note: it also doesn't work properly
				        		//camControls2.lookSpeed = lookSpeed;//0.05;//note: it also doesn't work properly
							//camControls.movementSpeed = moveSpeed; //0.25;//note: it also doesn't work properly
							//camControls.lookSpeed = lookSpeed; //0.05;//note: it also doesn't work properly
				
							autoForward = false;
							autoBackward = false;
							camControls.moveBackward = false;
							camControls2.moveBackward = false;
						
					
							camControls.moveForward = false;
							camControls2.moveForward = false;
							if(record) {guivalues.saveimage();}
							//reward += 0.001; 
							//console.log("STOP!");
						}
					}else{
						if( transdecLoaded && transdec2Loaded && obstaclesLoaded && obstacles2Loaded ){
							autoBackward = true;
							autoForward = false;
							camControls.moveBackward = true;
							camControls2.moveBackward = true;

					
							camControls.moveForward = false;
							camControls2.moveForward = false;
							if(record) {guivalues.saveimage();}
							//reward += 0.001; 
							console.log("GOOD! Move Backward towards target!");
						}else{  //var moveSpeed = ((camControls2.movementSpeed / Math.abs(errorYaw)) * (newdistancetotarget/20)) + 0.15 ;
							//var lookSpeed = (camControls2.lookSpeed / Math.abs(errorYaw));
							//camControls2.movementSpeed = moveSpeed; //0.25;//note: it also doesn't work properly
			        			//camControls2.lookSpeed = lookSpeed;//0.05;//note: it also doesn't work properly
							//camControls.movementSpeed = moveSpeed; //0.25;//note: it also doesn't work properly
							//camControls.lookSpeed = lookSpeed; //0.05;//note: it also doesn't work properly
					      
							autoBackward = false;
							autoFoward = true;
							camControls.moveBackward = false;
							camControls2.moveBackward = false;
						
					
							camControls.moveForward = false;
							camControls2.moveForward = false;
							if(record) {guivalues.saveimage();}
							//reward += 0.001; 
							//console.log("STOP!");
						}
					}
				*/
				water.material.uniforms.time.value += 1.0 / 60.0; //speed of water motion(wind chop)
				water.render(); //render water surface
				water2.material.uniforms.time.value += 1.0 / 60.0; //speed of water motion(wind chop)
				water2.render(); //render water surface
				caustic.material.uniforms.time.value += 1.0 / 30.0; //speed of water motion(wind chop)
				caustic.render(); //render water surface
				caustic2.material.uniforms.time.value += 1.0 / 30.0; //speed of water motion(wind chop)
				caustic2.render(); //render water surface
				
				
				//source:https://github.com/dirkk0/threejs_daynight/blob/master/index.html
				var nsin = Math.abs(Math.sin(timeSolar));
				var ncos = Math.cos(timeSolar);
				//console.log(nsin);
				// set the sun
				spotLightRED.position.set( -2000*ncos, 2000*nsin, 1500*ncos+1000);
				spotLightRED.lookAt (0,0,0);
				//spotLightRED2.position.copy( spotLightRED );
				spotLightRED2.position.set( -2000*ncos, 2000*nsin, 1500*ncos+1000);
				spotLightRED2.lookAt (0,0,0);
				//spotLightGREEN.position.copy( spotLightRED );
				spotLightGREEN.position.set( -2000*ncos, 2000*nsin, 1500*ncos+1000);
				spotLightGREEN.lookAt (0,0,0);
				//spotLightGREEN2.position.copy( spotLightRED );
				spotLightGREEN2.position.set( -2000*ncos, 2000*nsin, 1500*ncos+1000);
				spotLightGREEN2.lookAt (0,0,0);
				//spotLightBLUE.position.copy( spotLightRED );
				spotLightBLUE.position.set( -2000*ncos, 2000*nsin, 1500*ncos+1000);
				spotLightBLUE.lookAt (0,0,0);
				//spotLightBLUE2.position.copy( spotLightRED );
				spotLightBLUE2.position.set( -2000*ncos, 2000*nsin, 1500*ncos+1000);
				spotLightBLUE2.lookAt (0,0,0);
				//source:https://github.com/dirkk0/threejs_daynight/blob/master/index.html
				//spotLightSUN.position.set( -1900*ncos, 1900*nsin, 1425*ncos+1000);
				//spotLightSUN.lookAt ( spotLightRED.position );
				
				if ( record && false ){ // ATTENTION: remove the "&& false" for websocket!!
					//testWebSocket()
					animate();
					imgData2 = renderer2.domElement.toDataURL();
					doSend("250" + "," + imgData2);// + "," + imgData2);
					/*
					if( frameCounter % 5 === 0 ){
						imgData1 = renderer.domElement.toDataURL();
						imgData2 = renderer2.domElement.toDataURL();
						//websocket transmit
						//doSend("Frame: " + frameCounter + " X: " + camera2.position.x + " Y: " + camera2.position.y + " Z: " + camera2.position.z + " Yaw: " + camera.rotation.y + " Mouse.x: " + mouseposx + " Mouse.y: " + mouseposy + " xacceleration is: " + deltaxacceleration +" yacceleration is: " + deltayacceleration + " zacceleration is: " + deltazacceleration + " zacceleration is: " + deltazacceleration + " xvelocity is: " + deltaxvelocity + " yvelocity is: " + deltayvelocity + " zvelocity is: " + deltazvelocity + " yangvelocity is: " + deltayangvelocity + " Screenshot1(Base64): " + imgData1 + " Screenshot2(Base64): " + imgData2);
						doSend(frameCounter + "," + camera2.position.x + "," + camera2.position.y + "," + camera2.position.z + "," + camera.rotation.y + "," + mouseposx + "," + mouseposy + "," + "0" + "," + "0" + "," + "0" + "," + "0" + ",snap1" + imgData1 + ",snap2" + imgData2);										
					}
					if( frameCounter % 5 != 0 ){
					//doSend("Frame:(no screenshot) " + frameCounter + " X: " + camera2.position.x + " Y: " + camera2.position.y + " Z: " + camera2.position.z + " Yaw: " + camera.rotation.y + " Mouse.x: " + mouseposx + " Mouse.y: " + mouseposy + " xacceleration is: " + deltaxacceleration +" yacceleration is: " + deltayacceleration + " zacceleration is: " + deltazacceleration + " zacceleration is: " + deltazacceleration + " xvelocity is: " + deltaxvelocity + " yvelocity is: " + deltayvelocity + " zvelocity is: " + deltazvelocity + " yangvelocity is: " + deltayangvelocity);
					doSend(frameCounter + "," + camera2.position.x + "," + camera2.position.y + "," + camera2.position.z + "," + camera.rotation.y + "," + mouseposx + "," + mouseposy + "," + "0" + "," + "0" + "," + "0" + "," + "0");										
					}*/
				}
				frameCounter++;


				sphere.position.copy( spotLightRED.position );
				//sphere2.position.copy( spotLightSUN.position );

				var lightFix = new function(){
					//this function uses a spectra specific implementation of the beer-lambert law to modify lighting intensity as a function of depth
					//when combined with colored exponential fog, it is a reasonable approximation for the color specific light attenuation observed underwater 
				
					this.lightDepthFix = function(){
					intensity1 = .95;
					intensity2 = .25;
					intensity3 = .375;
					
					depthcm = (camera2.position.y + (0.9)) * (-100.0);//meter to cm conversion
					adjIntensity1RED = (intensity1 * (Math.exp(-.006 * depthcm))); //red spectra attenuation coefficient
					adjIntensity1GREEN = (intensity1 * (Math.exp(-.00032 * depthcm))); //green spectra attenuation coefficient
					adjIntensity1BLUE = (intensity1 * (Math.exp(-.000247 * depthcm))); //blue spectra attenuation coefficient
					
					adjIntensity2RED = (intensity2 * (Math.exp(-.006 * depthcm)));
					adjIntensity2GREEN = (intensity2 * (Math.exp(-.00032 * depthcm)));
					adjIntensity2BLUE = (intensity2 * (Math.exp(-.000247 * depthcm)));
					
					adjIntensity3RED = (intensity3 * (Math.exp(-.006 * depthcm)));
					adjIntensity3GREEN = (intensity3 * (Math.exp(-.00032 * depthcm)));
					adjIntensity3BLUE = (intensity3 * (Math.exp(-.000247 * depthcm)));

					
					//artificial sun light set
					spotLightRED.intensity = adjIntensity1RED;
					spotLightRED2.intensity = adjIntensity1RED;
					spotLightGREEN.intensity = adjIntensity1GREEN;
					spotLightGREEN2.intensity = adjIntensity1GREEN;
					spotLightBLUE.intensity = adjIntensity1BLUE;
					spotLightBLUE2.intensity = adjIntensity1BLUE;
					
					//hemisphere light set
					lightRed.intensity = adjIntensity2RED;
					light2Red.intensity = adjIntensity2RED;
					lightGreen.intensity = adjIntensity2GREEN;
					light2Green.intensity = adjIntensity2GREEN;
					lightBlue.intensity = adjIntensity2BLUE;
					light2Blue.intensity = adjIntensity2BLUE;

					//ambient light set
					ambientLightRed.intensity = adjIntensity3RED;
					ambientLight2Red.intensity = adjIntensity3RED;
					ambientLightGreen.intensity = adjIntensity3GREEN;
					ambientLight2Green.intensity = adjIntensity3GREEN;
					ambientLightBlue.intensity = adjIntensity3BLUE;
					ambientLight2Blue.intensity = adjIntensity3BLUE;
					
				    };
				}
				if ( keyboard.pressed("shift") ){//almost positive this is original code
					camControls2.movementSpeed = 2.0;//note: it also doesn't work properly
					camControls2.lookSpeed = 0.15;//note: it also doesn't work properly
					camControls.movementSpeed = 2.0;//note: it also doesn't work properly
					camControls.lookSpeed = 0.15;//note: it also doesn't work properly
					}
				if ( keyboard.pressed("ctrl") ){//almost positive this is original code
					camControls2.movementSpeed = 0.25;//note: it also doesn't work properly
					camControls2.lookSpeed = 0.05;//note: it also doesn't work properly
					camControls.movementSpeed = 0.25;//note: it also doesn't work properly
					camControls.lookSpeed = 0.05;//note: it also doesn't work properly
					}
				if ( keyboard.pressed("E") ){//almost positive this is original code
					camera2.rotateY(Math.PI/-1);//original code
					camera2.rotateZ((Math.PI)/-1);//original code
					}//this line is probably safe :P
				if ( keyboard.pressed("3") ){//almost positive this is original code
					scene.overrideMaterial = new THREE.MeshDepthMaterial();
				}
				if ( keyboard.pressed("C") ){//almost positive this is original code
					scene.overrideMaterial = null;
				}
				if ( keyboard.pressed("J") ) {guivalues.getLostBoth();}
				if ( keyboard.pressed("K") ) {guivalues.getLostComp();}
				if ( keyboard.pressed("L") ) {guivalues.getLostPract();}
				if ( keyboard.pressed("W") ) {guivalues.saveimage();}
				if ( keyboard.pressed("D") ) {guivalues.saveimage();}
				if ( keyboard.pressed("A") ) {guivalues.saveimage();}
				if ( keyboard.pressed("S") ) {guivalues.saveimage();}
				if ( keyboard.pressed("Q") ) {guivalues.resetGame();}
				
//				if ( keyboard.pressed("R") ) {guivalues.lookAtRedBuoy();}
				if ( keyboard.pressed("Y") ) {guivalues.lookAtYellowBuoy();}
				if ( keyboard.pressed("G") ) {guivalues.lookAtGreenBuoy();}
				
				if ( keyboard.pressed("R") ){record = true; console.log("Recording NOW");}		
				if ( keyboard.pressed("T") ){autopilotrun = true; console.log("Engage Autopilot");}
				if ( keyboard.pressed("M") ){record = false; autopilotrun = false; console.log("Recording STOP");}
				if ( keyboard.pressed("Y") ){record = true; autopilotrun = true;}
				if ( keyboard.pressed("N") ){console.log("imgData1: " + imgData1); console.log(", imgData2: " + imgData2);}
				if ( keyboard.pressed("U") ){guivalues.saveimage(); }
				if ( keyboard.pressed("B") ){guivalues.bumpPos(); }
				
				
				

				if ( keyboard.pressed("P") ) {guivalues.savetext("labels");}//lightFix.lightDepthFix();}
				if ( keyboard.pressed("V") ) {
					//guivalues.lightDepthFix();
					guivalues.randomVis();
				}
				
				///////////////////////////////////////////////////////////////////////////////////////////////////
				//This section determines if the camera position is within the "hitbox" to award objective points//
				///////////////////////////////////////////////////////////////////////////////////////////////////
				if ( camera2.position.x < -15.27 && camera2.position.x > -16.27 && camera2.position.z < -21.63 && camera2.position.z > -22.63) {
					pathmarker1Points = true;
					console.log("Pathmarker1 Points!");
					if(savecsv2){
						savecsv2 = false;
						//imagenumber = 0; 
						//imageletter++; 
						audio.play();
						//guivalues.savetext("pathmarker1save");
					}
				}
				if ( camera2.position.x < -24.26 && camera2.position.x > -25.26 && camera2.position.z < -18.84 && camera2.position.z > -19.84 ) {
					pathmarker2Points = true;
					console.log("Pathmarker2 Points!");
					if(savecsv6){
						savecsv6 = false;
						//imagenumber = 0; 
						//imageletter++; 
						audio.play();
						//guivalues.savetext("pathmarker2save");
					}
				}
				if ( camera2.position.x < -24.2 && camera2.position.x > -25.2 && camera2.position.z < -18.91 && camera2.position.z > -19.91 ) {
					pathmarker3Points = true;
					console.log("Pathmarker3 Points!");
				}
				if ( camera2.position.x < -29.35 && camera2.position.x > -30.35 && camera2.position.z < -11.24 && camera2.position.z > -12.24 ) {
					pathmarker4Points = true;
					console.log("Pathmarker4 Points!");
				}
				if ( camera2.position.x < -30.99 && camera2.position.x > -31.59 && camera2.position.z < 2.16 && camera2.position.z > 1.56 ) {
					pathmarker5Points = true;
					console.log("Pathmarker5 Points!");
				}
				if ( camera2.position.x < -29.27 && camera2.position.x > -29.87 && camera2.position.z < 12.74 && camera2.position.z > 12.14 ) {
					pathmarker6Points = true;
					console.log("Pathmarker6 Points!");
				}
				if ( camera2.position.x < -23.27 && camera2.position.x > -23.87 && camera2.position.z < 15.71 && camera2.position.z > 15.11 ) {
					pathmarker7Points = true;
					console.log("Pathmarker7 Points!");
				}
//				if ( frameCounter >= desiredFrameCounter1) {buoy1Backup = true;}
//				if ( frameCounter >= desiredFrameCounter2) {buoy2Backup = true;}
				if ( camera2.position.x < -22.64 && camera2.position.x > -23.64 && camera2.position.y < -1.7 && camera2.position.y > -2.7 && camera2.position.z < -21.21 && camera2.position.z > -22.21 ) {
					buoy1Points = true;
					console.log("Buoy1 Points!");
					if(savecsv3){
						savecsv3 = false;
						//desiredFrameCounter1 = frameCounter +50000;
						//imagenumber = 0; 
						//imageletter++; 
						audio.play();
						//guivalues.savetext("buoy1save");
					}
				}
				if ( camera2.position.x < -21.29 && camera2.position.x > -22.29 && camera2.position.y < -1.53 && camera2.position.y > -2.53 && camera2.position.z < -19.14 && camera2.position.z > -20.14 ) {
					buoy2Points = true;
					console.log("Buoy2 Points!");
					if(savecsv4){
						savecsv4 = false;
						//desiredFrameCounter1 = frameCounter +50000;
						//imagenumber = 0; 
						//imageletter++;
						audio.play();
						//guivalues.savetext("buoy2save");
					}
				}
				if ( camera2.position.x < -21.97 && camera2.position.x > -22.97 && camera2.position.y < -1.62 && camera2.position.y > -2.62 && camera2.position.z < -20.19 && camera2.position.z > -21.19 ) {					
					buoy3Points = true;
					console.log("Buoy3 Points!");
					if(savecsv5){
						savecsv5 = false;
						//imagenumber = 0; 
						//imageletter++; 
						audio.play();
						//guivalues.savetext("buoy3save");
					}
				}
				if ( (camera2.position.x < -28.79 && camera2.position.x > -29.69 && camera2.position.y < -1.1 && camera2.position.y > -2.22 && camera2.position.z < -13.13 && camera2.position.z > -14.13) || (camera2.position.x < -29.33 && camera2.position.x > -29.85 && camera2.position.y < -1.3 && camera2.position.y > -2.12 && camera2.position.z < -13.53 && camera2.position.z > -14.13)) {
					maneuverPoints = true;
					console.log("Maneuver Points!");
				}
				if ( camera2.position.x < -32.66 && camera2.position.x > -33.26 && camera2.position.z > 11.75 && camera2.position.z < 12.35 ) {
					octagon1Center = true;
					console.log("Octagon1Center!");
				}
				if ( camera2.position.x < -32.66 && camera2.position.x > -33.26 && camera2.position.y < -1.0 && camera2.position.y > -1.1 && camera2.position.z > 11.75 && camera2.position.z < 12.35 ) {
					octagon1Points = true;
					console.log("Octagon1 Points!");
				}
				if ( octagon1Points && camera2.position.x < -32.66 && camera2.position.x > -33.26 && camera2.position.y < -3.0 && camera2.position.y > -3.5 && camera2.position.z > 11.75 && camera2.position.z < 12.35 ) {
					octagon1Done = true;
					console.log("Octagon1done Points!");
				}
				if ( camera2.position.x < -20.78 && camera2.position.x > -21.38 && camera2.position.z > 17.68 && camera2.position.z < 18.28 ) {
					octagon2Center = true;
					console.log("Octagon2Center!");
				}
				if ( camera2.position.x < -20.78 && camera2.position.x > -21.38 && camera2.position.y < -1.0 && camera2.position.y > -1.1 && camera2.position.z > 17.68 && camera2.position.z < 18.28 ) {
					octagon2Points = true;
					console.log("Octagon2 Points!");
				}





				///////////////////////////////////////////////////////////////////////////////////////////////////
				//This section determines if the camera position is within the "hitbox" to award objective points//
				///////////////////////////////////////////////////////////////////////////////////////////////////

				///////////////////////////////////////////////////////////////
				//This section tallys objective points that have been awarded//
				///////////////////////////////////////////////////////////////
												
				var totalPoints = 0;
				validationgatePoints = true;
				if ( validationgatePoints ) {
					totalPoints += 250;
					if ( pathmarker1Points ) {
						totalPoints += 100;
					}
					if ( pathmarker2Points ) {
						totalPoints += 100;
					}
					if ( pathmarker3Points ) {
						totalPoints += 100;
					}
					if ( pathmarker4Points ) {
						totalPoints += 100;
					}
					if ( pathmarker5Points ) {
						totalPoints += 100;
					}
					if ( pathmarker6Points ) {
						totalPoints += 100;
					}
					if ( pathmarker7Points ) {
						totalPoints += 100;
					}
					if ( octagon1Points ) {
						totalPoints += 500;
					}
					if ( octagon2Points ) {
						totalPoints += 2000;
					}
					if ( buoy1Points ) {
						totalPoints += 400;
					}
					if ( buoy2Points ) {
						totalPoints += 400;
					}
					if ( buoy3Points ) {
						totalPoints += 400;
					}
					if ( maneuverPoints ) {
						totalPoints += 600;
					}
				}
				console.log("Total Points: " + totalPoints);

				///////////////////////////////////////////////////////////////
				//This section tallys objective points that have been awarded//
				///////////////////////////////////////////////////////////////

				lightFix.lightDepthFix();
				//if ( true ) {
					//guivalues.lightDepthFix();

				//}
				if ( camera2.position.y > -0.80) { //cheap hack to bypass the fog entangling impact of using a single .obj/.mtl file above and below water
						//scene2.fog.density = 0.0; 
						//scene.fog.density = 0.0;
						//guivalues.normalLight();
					}
				if ( camera2.position.y < -0.81 && camera2.position.y > -.9) { //cheap hack to bypass the fog entangling impact of using a single .obj/.mtl file above and below water
						scene2.fog.density = 0.1875; 
						scene.fog.density = 0.1875;
						lightFix.lightDepthFix();
					}
					
				if ( camera2.position.y < -5.5 ) { //cheap hack to bound behavior
						camera2.position.y = -5.5; 
						camera.position.y = -5.5; 
					}
//				if ( camera2.position.y > 5.5 ) { //normal ceilling
				if ( camera2.position.y > -1.04 ) { //cheap hack to bound behavior
						//camera2.position.y = 5.5; 
						//camera.position.y = 5.5; 

						camera2.position.y = -1.04; 
						camera.position.y = -1.04; 
					}
				if(mousething){guivalues.saveimage(); mousething = false;}
				
				renderer.render( scene, camera ); //render everything else
				renderer2.render( scene2, camera2 ); //render everything else
			}
			//source: MIT License OR "This code no longer appears to contain anything that belongs to josdirksen?"

		</script>
	</body>
</html>
